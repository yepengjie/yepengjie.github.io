<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件委托</title>
      <link href="/2020/04/09/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2020/04/09/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>]]></content>
      
      
      <categories>
          
          <category> js技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2020/04/07/%E9%97%AD%E5%8C%85/"/>
      <url>/2020/04/07/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>这是在博客上看到的一篇文章讲的非常的详细，我记录下来，以求一同成长，但是我建议还是要自己敲一遍，只有理解了记住了才是自己的。摘录至<a href="https://blog.csdn.net/weixin_43586120/article/details/89456183" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43586120/article/details/89456183</a></p><h2 id="1、闭包基本概念"><a href="#1、闭包基本概念" class="headerlink" title="1、闭包基本概念"></a>1、闭包基本概念</h2><p>闭包函数：声明在一个函数中的函数，叫做闭包函数。<br>闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</p><h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p>  让外部访问函数内部变量成为可能；</p><p>  局部变量会常驻在内存中；</p><p>  可以避免使用全局变量，防止全局变量污染；</p><p>  会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p><h2 id="3、闭包的创建：­­­"><a href="#3、闭包的创建：­­­" class="headerlink" title="3、闭包的创建：­­­"></a>3、闭包的创建：­­­</h2><p>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。</p><p>闭包内存泄漏为： key = value，key 被删除了 value 常驻内存中; 局部变量闭包升级版（中间引用的变量） =&gt; 自由变量；<br>上面的都是什么鬼，是人话么，能看懂早就看懂了，生气······<br>不过，答应我，看完例子再回看上面的概念，会理解的更！透！彻！</p><h2 id="4、闭包的应用场景"><a href="#4、闭包的应用场景" class="headerlink" title="4、闭包的应用场景"></a>4、闭包的应用场景</h2><p>结论：闭包找到的是同一地址中父级函数中对应变量最终的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    function funA()&#123;</span><br><span class="line">    var a &#x3D; 10;  &#x2F;&#x2F; funA的活动对象之中;</span><br><span class="line">    return function()&#123;   &#x2F;&#x2F;匿名函数的活动对象;</span><br><span class="line">            alert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var b &#x3D; funA();</span><br><span class="line">    b();  &#x2F;&#x2F;10</span><br><span class="line">&#96;&#96;&#96;例子2</span><br><span class="line">    function outerFn()&#123;</span><br><span class="line">    var i &#x3D; 0; </span><br><span class="line">    function innerFn()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return innerFn;</span><br><span class="line">    &#125;</span><br><span class="line">    var inner &#x3D; outerFn();  &#x2F;&#x2F;每次外部函数执行的时候，外部函数的地址不同，都会重新创建一个新的地址</span><br><span class="line">    inner();</span><br><span class="line">    inner();</span><br><span class="line">    inner();</span><br><span class="line">    var inner2 &#x3D; outerFn();</span><br><span class="line">    inner2();</span><br><span class="line">    inner2();</span><br><span class="line">    inner2();   &#x2F;&#x2F;1 2 3 1 2 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i &#x3D; 0;</span><br><span class="line">function outerFn()&#123;</span><br><span class="line">function innnerFn()&#123;</span><br><span class="line">    i++;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">return innnerFn;</span><br><span class="line">&#125;</span><br><span class="line">var inner1 &#x3D; outerFn();</span><br><span class="line">var inner2 &#x3D; outerFn();</span><br><span class="line">inner1();</span><br><span class="line">inner2();</span><br><span class="line">inner1();</span><br><span class="line">inner2();     &#x2F;&#x2F;1 2 3 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    function fn()&#123;</span><br><span class="line">        var a &#x3D; 3;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            return  ++a;                                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(fn()());  &#x2F;&#x2F;4</span><br><span class="line">    alert(fn()());  &#x2F;&#x2F;4 </span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">&#96;&#96;&#96; 例子5   </span><br><span class="line">    function outerFn()&#123;</span><br><span class="line">    var i &#x3D; 0;</span><br><span class="line">    function innnerFn()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return innnerFn;</span><br><span class="line">    &#125;</span><br><span class="line">    var inner1 &#x3D; outerFn();</span><br><span class="line">    var inner2 &#x3D; outerFn();</span><br><span class="line">    inner1();</span><br><span class="line">    inner2();</span><br><span class="line">    inner1();</span><br><span class="line">    inner2();    &#x2F;&#x2F;1 1 2 2</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">&#96;&#96;&#96; 例子6 </span><br><span class="line">    (function() &#123; </span><br><span class="line">        var m &#x3D; 0; </span><br><span class="line">        function getM() &#123; return m; &#125; </span><br><span class="line">        function seta(val) &#123; m &#x3D; val; &#125; </span><br><span class="line">        window.g &#x3D; getM; </span><br><span class="line">        window.f &#x3D; seta; </span><br><span class="line">    &#125;)(); </span><br><span class="line">    f(100);</span><br><span class="line">    console.info(g());   &#x2F;&#x2F;100  闭包找到的是同一地址中父级函数中对应变量最终的值</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">&#96;&#96;&#96; 例子7   </span><br><span class="line">    function a() &#123; </span><br><span class="line">    var i &#x3D; 0; </span><br><span class="line">    function b() &#123; alert(++i); &#125; </span><br><span class="line">    return b; </span><br><span class="line">    &#125; </span><br><span class="line">    var c &#x3D; a(); </span><br><span class="line">    c();      &#x2F;&#x2F;1 </span><br><span class="line">    c();      &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    function f() &#123; </span><br><span class="line">    var count &#x3D; 0; </span><br><span class="line">    return  function() &#123; </span><br><span class="line">        count++; </span><br><span class="line">        console.info(count); </span><br><span class="line">    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    var t1 &#x3D; f();</span><br><span class="line">    t1();     &#x2F;&#x2F;1 </span><br><span class="line">    t1();     &#x2F;&#x2F;2 </span><br><span class="line">    t1();     &#x2F;&#x2F;3 </span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">&#96;&#96;&#96; 例子9</span><br><span class="line">    var add &#x3D; function(x) &#123; </span><br><span class="line">    var sum &#x3D; 1; </span><br><span class="line">    var tmp &#x3D; function(x) &#123; </span><br><span class="line">        sum &#x3D; sum + x; </span><br><span class="line">        return tmp;    </span><br><span class="line">    &#125; </span><br><span class="line">    tmp.toString &#x3D; function() &#123; </span><br><span class="line">        return sum; </span><br><span class="line">    &#125;</span><br><span class="line">    return tmp; </span><br><span class="line">    &#125; </span><br><span class="line">    alert(add(1)(2)(3));     &#x2F;&#x2F;6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var lis &#x3D; document.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;0;i&lt;lis.length;i++)&#123;</span><br><span class="line">(function(i)&#123;</span><br><span class="line">    lis[i].onclick &#x3D; function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(i);       &#x2F;&#x2F;事件处理函数中闭包的写法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">    var x &#x3D; 1;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(++x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1()();   &#x2F;&#x2F;2</span><br><span class="line">m1()();   &#x2F;&#x2F;2</span><br><span class="line">m1()();   &#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">var m2 &#x3D; m1();</span><br><span class="line">m2();   &#x2F;&#x2F;2</span><br><span class="line">m2();   &#x2F;&#x2F;3</span><br><span class="line">m2();   &#x2F;&#x2F;4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var  fn&#x3D;(function()&#123;</span><br><span class="line">var  i&#x3D;10;</span><br><span class="line">function  fn()&#123;</span><br><span class="line">    console.log(++i);</span><br><span class="line">&#125;</span><br><span class="line">return   fn;</span><br><span class="line">&#125;)() </span><br><span class="line">fn();   &#x2F;&#x2F;11</span><br><span class="line">fn();   &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function love1()&#123;</span><br><span class="line"> var num &#x3D; 223;</span><br><span class="line"> var me1 &#x3D; function() &#123;</span><br><span class="line">       console.log(num);</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> return me1;</span><br><span class="line">&#125;</span><br><span class="line">var loveme1 &#x3D; love1();</span><br><span class="line">loveme1();   &#x2F;&#x2F;输出224</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun(n,o) &#123;</span><br><span class="line">    console.log(o);</span><br><span class="line">    return &#123;</span><br><span class="line">        fun:function(m) &#123;</span><br><span class="line">            return fun(m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; fun(0);  &#x2F;&#x2F;undefined</span><br><span class="line">a.fun(1);  &#x2F;&#x2F;0  </span><br><span class="line">a.fun(2);  &#x2F;&#x2F;0  </span><br><span class="line">a.fun(3);  &#x2F;&#x2F;0  </span><br><span class="line">var b &#x3D; fun(0).fun(1).fun(2).fun(3);   &#x2F;&#x2F;undefined  0  1  2</span><br><span class="line">var c &#x3D; fun(0).fun(1);  </span><br><span class="line">c.fun(2);  </span><br><span class="line">c.fun(3);  &#x2F;&#x2F;undefined  0  1  1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">var arr &#x3D; [];</span><br><span class="line">for(var i &#x3D; 0;i &lt; 5;i ++)&#123;</span><br><span class="line">    arr[i] &#x3D; function()&#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var list &#x3D; fn();</span><br><span class="line">for(var i &#x3D; 0,len &#x3D; list.length;i &lt; len ; i ++)&#123;</span><br><span class="line">console.log(list[i]());</span><br><span class="line">&#125;  &#x2F;&#x2F;5 5 5 5 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">var arr &#x3D; [];</span><br><span class="line">for(var i &#x3D; 0;i &lt; 5;i ++)&#123;</span><br><span class="line">    arr[i] &#x3D; (function(i)&#123;</span><br><span class="line">        return function ()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">var list &#x3D; fn();</span><br><span class="line">for(var i &#x3D; 0,len &#x3D; list.length;i &lt; len ; i ++)&#123;</span><br><span class="line">console.log(list[i]());</span><br><span class="line">&#125;  &#x2F;&#x2F;0 1 2 3 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数防抖和函数节流</title>
      <link href="/2020/04/07/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
      <url>/2020/04/07/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>函数防抖的基本概念：<br>    函数防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。<br>    简单来说，当一个动作连续触发，则只执行最后一次，这就是函数防抖。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        width: 800px;</span><br><span class="line">        height: 800px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;background: tomato&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;background: skyblue&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;background: red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;background: yellow&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload &#x3D; function () &#123;</span><br><span class="line">        function debounce (fn, delay) &#123;</span><br><span class="line">            let timer &#x3D; null</span><br><span class="line">            return function () &#123;</span><br><span class="line">                const context &#x3D; this</span><br><span class="line">                let args &#x3D; arguments</span><br><span class="line">                clearTimeout(timer) &#x2F;&#x2F; debounce调用时确保只执行一次</span><br><span class="line">                timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    fn.apply(context, args)</span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let num &#x3D; 0</span><br><span class="line">        function scrollTap () &#123;</span><br><span class="line">            num++</span><br><span class="line">            console.log(&#96;num数量 $&#123;num&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 此处的触发时间间隔设置的很小</span><br><span class="line">        document.addEventListener(&#39;scroll&#39;, debounce(scrollTap, 500))</span><br><span class="line">        &#x2F;&#x2F; document.addEventListener(&#39;scroll&#39;, scrollTap)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>函数节流的接本概念：<br>    限制一个函数在一定时间内只能执行一次<br>    举个例子，乘坐地铁，过闸机时，每个人进入后3秒后门关闭，等待下一个人进入。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const _.throttle &#x3D; (func, wait) &#x3D;&gt; &#123;</span><br><span class="line">    let timer;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">        if (timer) &#123;</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        func();</span><br><span class="line">        timer &#x3D; null;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="异同比较"><a href="#异同比较" class="headerlink" title="异同比较"></a>异同比较</h2><p>相同点：</p><p>都可以通过使用 setTimeout 实现。<br>目的都是，降低回调执行频率。节省计算资源。<br>不同点：</p><p>函数防抖，在一段连续操作结束后，处理回调，利用 clearTimeout 和 setTimeout 实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。<br>函数防抖关注一定时间连续触发，只在最后执行一次，而函数节流侧重于一段时间内只执行一次。</p>]]></content>
      
      
      <categories>
          
          <category> js技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element中input框的限制条件问题</title>
      <link href="/2020/04/02/element%E4%B8%ADinput%E6%A1%86%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/02/element%E4%B8%ADinput%E6%A1%86%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><pre><code>在项目中遇到的一个问题，因为element-input中的api限制了数据格式为number类型， 就不能限制长度了，反之亦然。</code></pre><h2 id="解决的方法："><a href="#解决的方法：" class="headerlink" title="解决的方法："></a>解决的方法：</h2><p>在el-input中添加 onkeypress=”return(/[0-9]/.test(String.fromCharCode(event.keyCode)))就可以了。但是最近发现了一个问题，好像不能限制具体的大小，比如让el-input限制最大输入3000就不行了，这里我就要用到rules了，代码如下<img src="/" class="lazyload" data-src="input.png"  alt="alt">，当然别忘了在el-input中加上maxlength。</p>]]></content>
      
      
      <categories>
          
          <category> 项目框架问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/01/hello-world/"/>
      <url>/2020/04/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
